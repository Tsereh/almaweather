{"version":3,"sources":["SearchField.js","MainWeather.js","WeatherRetriever.js","BookmarkedPlaces.js","App.js","serviceWorker.js","index.js"],"names":["SearchField","_Component","props","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","state","userInput","handleUserInput","bind","assertThisInitialized","clearUserInput","inherits","createClass","key","value","e","place","target","setState","onChange","clearSpan","react_default","a","createElement","className","onClick","InputGroup","Input","id","placeholder","Component","MainWeather","handlePlaceToggle","exists","savedPlaces","includes","hits","name","onPlaceBookmarkToggle","content","_this$props","typedPlace","placeNotFound","isLoading","error","selectedPlaceWeather","message","weather","description","charAt","toUpperCase","slice","src","icon","alt","main","Math","ceil","temp","Button","color","WeatherRetriever","prevProps","prevContext","_this2","responseOk","fetch","then","response","ok","json","data","concat","toConsumableArray","catch","_this$state","MainWeather_MainWeather","BookmarkedPlaces","handlePlaceClick","loadPlace","map","savedPlace","App","cookies","Cookies","undefined","get","updatePlace","togglePlaceBookmark","newPlace","placeToToggle","remove","sp","filter","item","current","Date","nextYear","setFullYear","getFullYear","set","path","expires","SearchField_SearchField","WeatherRetriever_WeatherRetriever","BookmarkedPlaces_BookmarkedPlaces","Boolean","window","location","hostname","match","ReactDOM","render","src_App_0","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"mTAOaA,EAAb,SAAAC,GACI,SAAAD,EAAYE,GAAO,IAAAC,EAAA,OAAAC,OAAAC,EAAA,EAAAD,CAAAE,KAAAN,IACfG,EAAAC,OAAAG,EAAA,EAAAH,CAAAE,KAAAF,OAAAI,EAAA,EAAAJ,CAAAJ,GAAAS,KAAAH,KAAMJ,KAEDQ,MAAQ,CAAEC,UAAW,IAE1BR,EAAKS,gBAAkBT,EAAKS,gBAAgBC,KAArBT,OAAAU,EAAA,EAAAV,QAAAU,EAAA,EAAAV,CAAAD,KACvBA,EAAKY,eAAiBZ,EAAKY,eAAeF,KAApBT,OAAAU,EAAA,EAAAV,QAAAU,EAAA,EAAAV,CAAAD,KANPA,EADvB,OAAAC,OAAAY,EAAA,EAAAZ,CAAAJ,EAAAC,GAAAG,OAAAa,EAAA,EAAAb,CAAAJ,EAAA,EAAAkB,IAAA,kBAAAC,MAAA,SAUoBC,GACZ,IAAMC,EAAQD,EAAEE,OAAOH,MACvBb,KAAKiB,SAAS,CAACZ,UAAWU,IAC1Bf,KAAKJ,MAAMsB,SAASH,KAb5B,CAAAH,IAAA,iBAAAC,MAAA,WAiBQb,KAAKiB,SAAS,CAACZ,UAAW,KAC1BL,KAAKJ,MAAMsB,SAAS,MAlB5B,CAAAN,IAAA,SAAAC,MAAA,WAsBQ,IAAIM,EAKJ,MAJ6B,KAAzBnB,KAAKI,MAAMC,YACXc,EAAYC,EAAAC,EAAAC,cAAA,QAAMC,UAAU,yBAAyBC,QAASxB,KAAKS,gBAAvD,WAIZW,EAAAC,EAAAC,cAACG,EAAA,EAAD,CAAYF,UAAU,gBAClBH,EAAAC,EAAAC,cAACI,EAAA,EAAD,CAAOC,GAAG,eAAeT,SAAUlB,KAAKM,gBAAiBO,MAAOb,KAAKI,MAAMC,UAAWuB,YAAY,WACjGT,OA9BjBzB,EAAA,CAAiCmC,qBCDpBC,EAAb,SAAAnC,GACI,SAAAmC,EAAYlC,GAAO,IAAAC,EAAA,OAAAC,OAAAC,EAAA,EAAAD,CAAAE,KAAA8B,IACfjC,EAAAC,OAAAG,EAAA,EAAAH,CAAAE,KAAAF,OAAAI,EAAA,EAAAJ,CAAAgC,GAAA3B,KAAAH,KAAMJ,KAEDmC,kBAAoBlC,EAAKkC,kBAAkBxB,KAAvBT,OAAAU,EAAA,EAAAV,QAAAU,EAAA,EAAAV,CAAAD,KAHVA,EADvB,OAAAC,OAAAY,EAAA,EAAAZ,CAAAgC,EAAAnC,GAAAG,OAAAa,EAAA,EAAAb,CAAAgC,EAAA,EAAAlB,IAAA,oBAAAC,MAAA,WAQQ,IAAMmB,EAAShC,KAAKJ,MAAMqC,YAAYC,SAASlC,KAAKJ,MAAMuC,KAAK,GAAGC,MAClEpC,KAAKJ,MAAMyC,sBAAsBrC,KAAKJ,MAAMuC,KAAK,GAAGC,KAAMJ,KATlE,CAAApB,IAAA,SAAAC,MAAA,WAYa,IAIDyB,EAJCC,EACyDvC,KAAKJ,MAA3D4C,EADHD,EACGC,WAAYL,EADfI,EACeJ,KAAMM,EADrBF,EACqBE,cAAeC,EADpCH,EACoCG,UAAWC,EAD/CJ,EAC+CI,MAC9CC,EAAuBT,EAAK,GAGlC,GAAIQ,EACAL,EAAUlB,EAAAC,EAAAC,cAAA,KAAGC,UAAU,yBAAyBoB,EAAME,cACnD,GAAmB,KAAfL,EACPF,EAAUlB,EAAAC,EAAAC,cAAA,KAAGC,UAAU,yBAAb,6EACP,GAAImB,GAA2D,OAA9CE,EAAqBE,QAAQ,GAAGC,YACpDT,EAAUlB,EAAAC,EAAAC,cAAA,KAAGC,UAAU,yBAAb,mBACP,GAAIkB,EACPH,EAAUlB,EAAAC,EAAAC,cAAA,KAAGC,UAAU,yBAAyBiB,EAAtC,kDACP,CAEH,IAAMR,EAAShC,KAAKJ,MAAMqC,YAAYC,SAASU,EAAqBR,MAEpEE,EACIlB,EAAAC,EAAAC,cAAA,WACIF,EAAAC,EAAAC,cAAA,SAAIsB,EAAqBE,QAAQ,GAAGC,YAAYC,OAAO,GAAGC,cAAeL,EAAqBE,QAAQ,GAAGC,YAAYG,MAAM,GAA3H,OAAmIN,EAAqBR,MACxJhB,EAAAC,EAAAC,cAAA,OAAKC,UAAU,cAAc4B,IAAK,mCAAqCP,EAAqBE,QAAQ,GAAGM,KAAO,OAAQC,IAAKT,EAAqBE,QAAQ,GAAGQ,KAAO,UAClKlC,EAAAC,EAAAC,cAAA,SAAIiC,KAAKC,KAA6C,IAAvCZ,EAAqBU,KAAKG,KAAK,SAAY,GAA1D,SACArC,EAAAC,EAAAC,cAACoC,EAAA,EAAD,CAAQnC,UAAU,eAAeoC,MAAM,UAAUnC,QAASxB,KAAK+B,mBAAqBC,EAAS,aAAe,aAKxH,OACIZ,EAAAC,EAAAC,cAAA,OAAKC,UAAU,gBACVe,OAzCjBR,EAAA,CAAiCD,aCIpB+B,EAAb,SAAAjE,GACI,SAAAiE,EAAYhE,GAAO,IAAAC,EAAA,OAAAC,OAAAC,EAAA,EAAAD,CAAAE,KAAA4D,IACf/D,EAAAC,OAAAG,EAAA,EAAAH,CAAAE,KAAAF,OAAAI,EAAA,EAAAJ,CAAA8D,GAAAzD,KAAAH,KAAMJ,KAEDQ,MAAQ,CACT+B,KAAM,CACF,CACIW,QAAS,CACL,CACIQ,KAAM,KACNP,YAAa,KACbK,KAAM,OAGdE,KAAM,CACNG,KAAM,MAENrB,KAAM,OAGdK,eAAe,EACfC,WAAW,EACXC,MAAO,MArBI9C,EADvB,OAAAC,OAAAY,EAAA,EAAAZ,CAAA8D,EAAAjE,GAAAG,OAAAa,EAAA,EAAAb,CAAA8D,EAAA,EAAAhD,IAAA,qBAAAC,MAAA,SA0BuBgD,EAAWC,GAAa,IAAAC,EAAA/D,KAEvC,GAAIA,KAAKJ,MAAMmB,QAAU8C,EAAU9C,OAA8B,KAArBf,KAAKJ,MAAMmB,MAAc,CACjEf,KAAKiB,SAAS,CAACyB,WAAW,IAE1B,IAAIsB,GAAa,EACjBC,MAnCA,qDAmCYjE,KAAKJ,MAAMmB,MAlClB,2CAmCAmD,KAAK,SAAAC,GACF,GAAIA,EAASC,GAGT,OAFAJ,GAAa,EACbD,EAAK9C,SAAS,CAAEwB,eAAe,IACxB0B,EAASE,OAEhBN,EAAK9C,SAAS,CAACwB,eAAe,MAGrCyB,KAAK,SAAAI,GACEN,EACAD,EAAK9C,SAAS,CAAEkB,KAAI,CAAGmC,GAAHC,OAAAzE,OAAA0E,EAAA,EAAA1E,CAAYiE,EAAK3D,MAAM+B,KAAKe,MAAM,EAAG,KAAKR,WAAW,IAEzEqB,EAAK9C,SAAS,CAACyB,WAAW,MAGjC+B,MAAM,SAAA9B,GAAK,OAAIoB,EAAK9C,SAAS,CAAE0B,QAAOD,WAAW,SAjDlE,CAAA9B,IAAA,SAAAC,MAAA,WAqDa,IAAA6D,EAC6C1E,KAAKI,MAA/C+B,EADHuC,EACGvC,KAAMM,EADTiC,EACSjC,cAAeC,EADxBgC,EACwBhC,UAAWC,EADnC+B,EACmC/B,MAExC,OACIvB,EAAAC,EAAAC,cAACqD,EAAD,CAAa1C,YAAajC,KAAKJ,MAAMqC,YAAaI,sBAAuBrC,KAAKJ,MAAMyC,sBAAuBG,WAAYxC,KAAKJ,MAAMmB,MAAOoB,KAAMA,EAAMM,cAAeA,EAAeC,UAAWA,EAAWC,MAAOA,QAzD5NiB,EAAA,CAAsC/B,aCHzB+C,EAAb,SAAAjF,GACI,SAAAiF,EAAYhF,GAAO,IAAAC,EAAA,OAAAC,OAAAC,EAAA,EAAAD,CAAAE,KAAA4E,IACf/E,EAAAC,OAAAG,EAAA,EAAAH,CAAAE,KAAAF,OAAAI,EAAA,EAAAJ,CAAA8E,GAAAzE,KAAAH,KAAMJ,KAEDiF,iBAAmBhF,EAAKgF,iBAAiBtE,KAAtBT,OAAAU,EAAA,EAAAV,QAAAU,EAAA,EAAAV,CAAAD,KAHTA,EADvB,OAAAC,OAAAY,EAAA,EAAAZ,CAAA8E,EAAAjF,GAAAG,OAAAa,EAAA,EAAAb,CAAA8E,EAAA,EAAAhE,IAAA,mBAAAC,MAAA,SAOqBC,GACbd,KAAKJ,MAAMkF,UAAUhE,EAAEE,OAAOH,SARtC,CAAAD,IAAA,SAAAC,MAAA,WAWa,IAAAkD,EAAA/D,KACL,OACIoB,EAAAC,EAAAC,cAAA,OAAKC,UAAU,qBACVvB,KAAKJ,MAAMqC,YAAY8C,IAAI,SAACC,EAAYpE,GAAb,OACxBQ,EAAAC,EAAAC,cAACoC,EAAA,EAAD,CAAQnC,UAAU,mBAAmBoC,MAAM,YAAY/C,IAAKA,EAAKC,MAAOmE,EAAYxD,QAASuC,EAAKc,kBAAmBG,UAfzIJ,EAAA,CAAsC/C,aCwDvBoD,cAvDX,SAAAA,EAAYrF,GAAO,IAAAC,EAAAC,OAAAC,EAAA,EAAAD,CAAAE,KAAAiF,GACfpF,EAAAC,OAAAG,EAAA,EAAAH,CAAAE,KAAAF,OAAAI,EAAA,EAAAJ,CAAAmF,GAAA9E,KAAAH,KAAMJ,IAEN,IAAMsF,EAAU,IAAIC,IAChBlD,EAAc,GAJH,YAKkBmD,IAA7BF,EAAQG,IAAI,iBACZpD,EAAciD,EAAQG,IAAI,gBAG9BxF,EAAKO,MAAQ,CACTW,MAAO,GACPmE,QAASA,EACTjD,YAAaA,GAGjBpC,EAAKyF,YAAczF,EAAKyF,YAAY/E,KAAjBT,OAAAU,EAAA,EAAAV,QAAAU,EAAA,EAAAV,CAAAD,KACnBA,EAAK0F,oBAAsB1F,EAAK0F,oBAAoBhF,KAAzBT,OAAAU,EAAA,EAAAV,QAAAU,EAAA,EAAAV,CAAAD,KAhBZA,2EAmBP2F,GACRxF,KAAKiB,SAAS,CACRF,MAAOyE,gDAIGC,EAAeC,GAC/B,IAAIC,EAEAA,EADDD,EACM1F,KAAKI,MAAM6B,YAAY2D,OAAO,SAAAC,GAAI,OAAIA,IAASJ,IAElD,CAAIA,GAAJlB,OAAAzE,OAAA0E,EAAA,EAAA1E,CAAsBE,KAAKI,MAAM6B,cAGvCjC,KAAKiB,SAAS,CACVgB,YAAa0D,IAIjB,IAAMG,EAAU,IAAIC,KACdC,EAAW,IAAID,KACrBC,EAASC,YAAYH,EAAQI,cAAgB,GAC7ClG,KAAKI,MAAM8E,QAAQiB,IAAI,cAAeR,EAAI,CAAES,KAAM,IAAKC,QAASL,qCAIhE,OACI5E,EAAAC,EAAAC,cAAA,OAAKC,UAAU,iBACXH,EAAAC,EAAAC,cAACgF,EAAD,CAAapF,SAAUlB,KAAKsF,cAC5BlE,EAAAC,EAAAC,cAACiF,EAAD,CAAkBxF,MAAOf,KAAKI,MAAMW,MAAOsB,sBAAuBrC,KAAKuF,oBAAqBtD,YAAajC,KAAKI,MAAM6B,cACpHb,EAAAC,EAAAC,cAACkF,EAAD,CAAkBvE,YAAajC,KAAKI,MAAM6B,YAAa6C,UAAW9E,KAAKsF,sBAlDrEzD,aCKE4E,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCXNC,IAASC,OAAO3F,EAAAC,EAAAC,cAAC0F,EAAD,MAASC,SAASC,eAAe,SD0H3C,kBAAmBC,WACrBA,UAAUC,cAAcC,MAAMnD,KAAK,SAAAoD,GACjCA,EAAaC","file":"static/js/main.754d5ed7.chunk.js","sourcesContent":["// This component is responsible for search field.\n// It updates it parents(App.js) state.place, every time user types something in to input field.\n\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport { InputGroup, Input } from 'reactstrap';\n\nexport class SearchField extends Component {\n    constructor(props) {\n        super(props);\n\n        this.state = { userInput: \"\"};\n\n        this.handleUserInput = this.handleUserInput.bind(this);\n        this.clearUserInput = this.clearUserInput.bind(this);\n    }\n\n    handleUserInput(e) {\n        const place = e.target.value;\n        this.setState({userInput: place});\n        this.props.onChange(place);\n    }\n\n    clearUserInput() {\n        this.setState({userInput: \"\"});\n        this.props.onChange(\"\");\n    }\n\n    render() {\n        let clearSpan;\n        if (this.state.userInput !== \"\") {\n            clearSpan = <span className=\"clear-span clear-cross\" onClick={this.clearUserInput}>â¨‰</span>;\n        }\n\n        return (\n            <InputGroup className=\"search-field\">\n                <Input id=\"search-field\" onChange={this.handleUserInput} value={this.state.userInput} placeholder=\"Search\" />\n                {clearSpan}\n            </InputGroup>\n        );\n    }\n}\n\nSearchField.propTypes = {\n    onChange: PropTypes.func.isRequired\n};","// Shows weather of currently selected place\n\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport { Button } from 'reactstrap';\n\nexport class MainWeather extends Component {\n    constructor(props) {\n        super(props);\n\n        this.handlePlaceToggle = this.handlePlaceToggle.bind(this);\n    }\n\n    handlePlaceToggle() {// Adds place to bookmarked places or removes it.\n        const exists = this.props.savedPlaces.includes(this.props.hits[0].name);\n        this.props.onPlaceBookmarkToggle(this.props.hits[0].name, exists);\n    }\n\n    render() {\n        const { typedPlace, hits, placeNotFound, isLoading, error } = this.props;\n        const selectedPlaceWeather = hits[0];\n\n        let content;\n        if (error) {\n            content = <p className=\"main-weather-oneliner\">{error.message}</p>;\n        } else if (typedPlace === \"\") {\n            content = <p className=\"main-weather-oneliner\">Please, enter a place name in to a search field to see it's weather.</p>;\n        } else if (isLoading ||Â selectedPlaceWeather.weather[0].description===null) {// Fixes problem when on fast typing async query messes up on first matching query.\n            content = <p className=\"main-weather-oneliner\">Loading...</p>;\n        } else if (placeNotFound) {\n            content = <p className=\"main-weather-oneliner\">{typedPlace} does not match any of known to us places.</p>;\n        } else {// Show weather info, place found.\n            // Is current place already bookmarked\n            const exists = this.props.savedPlaces.includes(selectedPlaceWeather.name);\n\n            content = (\n                <div>\n                    <p>{selectedPlaceWeather.weather[0].description.charAt(0).toUpperCase()}{selectedPlaceWeather.weather[0].description.slice(1)} in {selectedPlaceWeather.name}</p>\n                    <img className=\"weather-img\" src={\"http://openweathermap.org/img/w/\" + selectedPlaceWeather.weather[0].icon + \".png\"} alt={selectedPlaceWeather.weather[0].main + \" icon\"}/>\n                    <p>{Math.ceil((selectedPlaceWeather.main.temp-273.15)*10)/10}Â°C</p>\n                    <Button className=\"bookmark-btn\" color=\"primary\" onClick={this.handlePlaceToggle}>{ exists ? \"Bookmarked\" : \"Bookmark\" }</Button>\n                </div>\n            );\n        }\n\n        return (\n            <div className=\"main-weather\">\n                {content}\n            </div>\n        )\n    }\n}\n\nMainWeather.propTypes = {\n    savedPlaces: PropTypes.array,\n    onPlaceBookmarkToggle: PropTypes.func,\n    typedPlace: PropTypes.string,\n    hits: PropTypes.array,\n    placeNotFound: PropTypes.bool,\n    isLoading: PropTypes.bool,\n    error: PropTypes.object\n};","// This component fetches weather data, for a place given to it in parameters.\n// Three last hits stored in an array, to prevent from null pointer exceptions when async messes up on rapid successive fetches.\n\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport { MainWeather } from \"./MainWeather\";\n\nconst API = \"https://api.openweathermap.org/data/2.5/weather?q=\";\nconst APIAPPID = \"&APPID=c62f15c78133f4e346be75e47f0bb963\";// api key\n\nexport class WeatherRetriever extends Component {\n    constructor(props) {\n        super(props);\n\n        this.state = {\n            hits: [\n                {\n                    weather: [\n                        {\n                            main: null,\n                            description: null,\n                            icon: null\n                        }\n                    ],\n                    main: {\n                    temp: null\n                    },\n                    name: null\n                }\n            ],\n            placeNotFound: true,// true if fetched response status 404, to tell user that no places found by search parameters\n            isLoading: false,// true if fetching data, to show user some loading indicator\n            error: null// true if fetched error\n        };\n    }\n\n    componentDidUpdate(prevProps, prevContext) {\n        // Trying to fetch new weather data every time user types something in to searchfield\n        if (this.props.place !== prevProps.place && this.props.place !== \"\") {// To filter out some unnecessary fetches when props are empty or same as previous\n            this.setState({isLoading: true});// show loading indicator\n\n            let responseOk = false;\n            fetch(API + this.props.place + APIAPPID)\n                .then(response => {\n                    if (response.ok) {// Check that there is weather info fetched\n                        responseOk = true;\n                        this.setState({ placeNotFound: false });\n                        return response.json();\n                    } else {\n                        this.setState({placeNotFound: true });\n                    }\n                })\n                .then(data => {\n                    if (responseOk) {\n                        this.setState({ hits: [data, ...this.state.hits.slice(0, 2)], isLoading: false });\n                    } else {\n                        this.setState({isLoading: false});\n                    }\n                })\n                .catch(error => this.setState({ error, isLoading: false}));\n        }\n    }\n\n    render() {\n        const { hits, placeNotFound, isLoading, error } = this.state;\n\n        return (\n            <MainWeather savedPlaces={this.props.savedPlaces} onPlaceBookmarkToggle={this.props.onPlaceBookmarkToggle} typedPlace={this.props.place} hits={hits} placeNotFound={placeNotFound} isLoading={isLoading} error={error}/>\n        );\n    }\n}\n\nWeatherRetriever.propTypes = {\n    place: PropTypes.string,\n    onPlaceBookmarkToggle: PropTypes.func,\n    savedPlaces: PropTypes.array\n};","// This component shows list of bookmarked places.\n// Click on a particular saved place shows its weather information\n\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport { Button } from \"reactstrap\";\n\nexport class BookmarkedPlaces extends Component {\n    constructor(props) {\n        super(props);\n\n        this.handlePlaceClick = this.handlePlaceClick.bind(this);\n    }\n\n    handlePlaceClick(e) {\n        this.props.loadPlace(e.target.value);// Calls App.updatePlace(), to fetch data for clicked place\n    }\n\n    render() {\n        return (\n            <div className=\"bookmarked-places\">\n                {this.props.savedPlaces.map((savedPlace, key) =>\n                    <Button className=\"bookmarked-place\" color=\"secondary\" key={key} value={savedPlace} onClick={this.handlePlaceClick}>{savedPlace}</Button>\n                )}\n            </div>\n        )\n    }\n}\n\nBookmarkedPlaces.propTypes = {\n    savedPlaces: PropTypes.array,\n    loadPlace: PropTypes.func\n};","import React, { Component } from 'react';\nimport Cookies from 'universal-cookie';\nimport './App.css';\nimport { SearchField } from './SearchField';\nimport { WeatherRetriever } from \"./WeatherRetriever\";\nimport { BookmarkedPlaces } from \"./BookmarkedPlaces\";\n\nclass App extends Component {\n    constructor(props) {\n        super(props);\n\n        const cookies = new Cookies();\n        let savedPlaces = [];\n        if (cookies.get('savedPlaces')!==undefined) {\n            savedPlaces = cookies.get('savedPlaces')\n        }\n\n        this.state = {\n            place: \"\",\n            cookies: cookies,\n            savedPlaces: savedPlaces\n        };\n\n        this.updatePlace = this.updatePlace.bind(this);\n        this.togglePlaceBookmark = this.togglePlaceBookmark.bind(this);\n    }\n\n    updatePlace(newPlace) {// Updates state.place, to then be sent to weather retriever to fetch data for it\n        this.setState({\n              place: newPlace\n        });\n    }\n\n    togglePlaceBookmark(placeToToggle, remove) {// Adds or removes a new placeToToggle from savedPlaces state & cookies\n        let sp;\n        if(remove) {// Creates new array with or without placeToToggle\n            sp = this.state.savedPlaces.filter(item => item !== placeToToggle);\n        } else {\n            sp = [placeToToggle, ...this.state.savedPlaces];\n        }\n\n        this.setState({\n            savedPlaces: sp\n        });\n\n        // Save to cookies\n        const current = new Date();\n        const nextYear = new Date();\n        nextYear.setFullYear(current.getFullYear() + 1);\n        this.state.cookies.set('savedPlaces', sp, { path: '/', expires: nextYear });\n    }\n\n    render() {\n        return (\n            <div className=\"App container\">\n                <SearchField onChange={this.updatePlace}/>\n                <WeatherRetriever place={this.state.place} onPlaceBookmarkToggle={this.togglePlaceBookmark} savedPlaces={this.state.savedPlaces}/>\n                <BookmarkedPlaces savedPlaces={this.state.savedPlaces} loadPlace={this.updatePlace}/>\n            </div>\n        );\n    }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport 'bootstrap/dist/css/bootstrap.min.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}